

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>ch_util.timing &mdash; ch_util 20.10.0+44.g2b46683 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/katex-math.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"></script>
        <script src="../_static/katex_autorenderer.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ch_util.tools" href="ch_util.tools.html" />
    <link rel="prev" title="ch_util.rfi" href="ch_util.rfi.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ch_util
          

          
          </a>

          
            
            
              <div class="version">
                20.10.0+44.g2b46683
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../reference.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../reference.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ch_util._db_tables.html">ch_util._db_tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.andata.html">ch_util.andata</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.cal_utils.html">ch_util.cal_utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.chan_monitor.html">ch_util.chan_monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.connectdb.html">ch_util.connectdb</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.data_index.html">ch_util.data_index</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.data_quality.html">ch_util.data_quality</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.ephemeris.html">ch_util.ephemeris</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.finder.html">ch_util.finder</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.fluxcat.html">ch_util.fluxcat</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.holography.html">ch_util.holography</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.layout.html">ch_util.layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.ni_utils.html">ch_util.ni_utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.plot.html">ch_util.plot</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.rfi.html">ch_util.rfi</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">ch_util.timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch_util.tools.html">ch_util.tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ch_util</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../reference.html">API Reference</a> &raquo;</li>
        
      <li>ch_util.timing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/_autosummary/ch_util.timing.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-ch_util.timing">
<span id="ch-util-timing"></span><h1>ch_util.timing<a class="headerlink" href="#module-ch_util.timing" title="Permalink to this headline">¶</a></h1>
<p>Tools for timing jitter and delay corrections.</p>
<p>This module contains tools for using noise sources to correct
timing jitter and timing delay.</p>
<p class="rubric">Example</p>
<p>The function <a class="reference internal" href="#ch_util.timing.construct_delay_template" title="ch_util.timing.construct_delay_template"><code class="xref py py-meth docutils literal notranslate"><span class="pre">construct_delay_template()</span></code></a> generates a delay template from
measurements of the visibility between noise source inputs, which can
be used to remove the timing jitter in other data.</p>
<p>The user seldom needs to work with <a class="reference internal" href="#ch_util.timing.construct_delay_template" title="ch_util.timing.construct_delay_template"><code class="xref py py-meth docutils literal notranslate"><span class="pre">construct_delay_template()</span></code></a>
directly and can instead use several high-level functions and containers
that load the timing data, derive the timing correction using
<a class="reference internal" href="#ch_util.timing.construct_delay_template" title="ch_util.timing.construct_delay_template"><code class="xref py py-meth docutils literal notranslate"><span class="pre">construct_delay_template()</span></code></a>, and then enable easy application of
the timing correction to other data.</p>
<p>For example, to load the timing data and derive the timing correction from
a list of timing acquisition files (i.e., <cite>YYYYMMSSTHHMMSSZ_chimetiming_corr</cite>),
use the following:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">`tdata</span> <span class="pre">=</span> <span class="pre">TimingData.from_acq_h5(timing_acq_filenames)`</span></code></p>
</div></blockquote>
<p>This results in a <code class="xref py py-class docutils literal notranslate"><span class="pre">andata.CorrData</span></code> object that has additional
methods avaiable for applying the timing correction to other data.
For example, to obtain the complex gain for some freq, input, and time
that upon multiplication will remove the timing jitter, use the following:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">`tgain,</span> <span class="pre">tweight</span> <span class="pre">=</span> <span class="pre">tdata.get_gain(freq,</span> <span class="pre">input,</span> <span class="pre">time)`</span></code></p>
</div></blockquote>
<p>To apply the timing correction to the visibilities in an <code class="xref py py-class docutils literal notranslate"><span class="pre">andata.CorrData</span></code>
object called <cite>data</cite>, use the following:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">`tdata.apply_timing_correction(data)`</span></code></p>
</div></blockquote>
<p>The timing acquisitions must cover the span of time that you wish to correct.
If you have a list of data acquisition files and would like to obtain
the appropriate timing correction by searching the archive for the
corresponding timing acquisitons files, then use:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">`tdata</span> <span class="pre">=</span> <span class="pre">load_timing_correction(data_acq_filenames_full_path)`</span></code></p>
</div></blockquote>
<p>To print a summary of the timing correction, use:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">`print(tdata)`</span></code></p>
</div></blockquote>
<p class="rubric">Functions</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#ch_util.timing.construct_delay_template" title="ch_util.timing.construct_delay_template"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct_delay_template</span></code></a>(data[, …])</p></td>
<td><p>Construct a relative time delay template.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ch_util.timing.eigen_decomposition" title="ch_util.timing.eigen_decomposition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigen_decomposition</span></code></a>(vis, flag)</p></td>
<td><p>Eigenvalue decomposition of the visibility matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ch_util.timing.fit_poly_to_phase" title="ch_util.timing.fit_poly_to_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_poly_to_phase</span></code></a>(freq, resp, resp_error[, …])</p></td>
<td><p>Fit complex data versus frequency to a model consisting of a polynomial in phase.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ch_util.timing.load_timing_correction" title="ch_util.timing.load_timing_correction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_timing_correction</span></code></a>(files[, start, stop, …])</p></td>
<td><p>Find and load the appropriate timing correction for a list of corr acquisition files.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ch_util.timing.map_input_to_noise_source" title="ch_util.timing.map_input_to_noise_source"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_input_to_noise_source</span></code></a>(inputs, noise_sources)</p></td>
<td><p>Find the appropriate noise source to use to correct the phase of each input.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ch_util.timing.model_poly_phase" title="ch_util.timing.model_poly_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_poly_phase</span></code></a>(freq, *param)</p></td>
<td><p>Evaluate a polynomial model for the phase.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#ch_util.timing.TimingCorrection" title="ch_util.timing.TimingCorrection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimingCorrection</span></code></a>([h5_data])</p></td>
<td><p>Container that holds a timing correction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ch_util.timing.TimingData" title="ch_util.timing.TimingData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimingData</span></code></a>([h5_data])</p></td>
<td><p>Subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">andata.CorrData</span></code> for timing data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ch_util.timing.TimingInterpolator" title="ch_util.timing.TimingInterpolator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimingInterpolator</span></code></a>(x, y[, weight, flag, …])</p></td>
<td><p>Interpolation that is aware of flagged data and weights.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="ch_util.timing.TimingCorrection">
<em class="property">class </em><code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">TimingCorrection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h5_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ch_util.andata.html#ch_util.andata.BaseData" title="ch_util.andata.BaseData"><code class="xref py py-class docutils literal notranslate"><span class="pre">ch_util.andata.BaseData</span></code></a></p>
<p>Container that holds a timing correction.</p>
<p>Provides methods for applying that correction to other datasets.</p>
<p>Used to pick which subclass to instantiate based on attributes in
data.</p>
<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.alpha">
<em class="property">property </em><code class="sig-name descname">alpha</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the alpha array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.amp_to_delay">
<em class="property">property </em><code class="sig-name descname">amp_to_delay</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.amp_to_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>Return conversion from noise source amplitude variations to delay variations.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.apply_timing_correction">
<code class="sig-name descname">apply_timing_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timestream</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.apply_timing_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.apply_timing_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the timing correction to another visibility dataset.</p>
<p>This method uses the get_gain or get_stacked_tau method, depending
on whether or not the visibilities have been stacked.  It acccepts
and passes along keyword arguments for those method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestream</strong> (<em>andata.CorrData / equivalent</em><em> or </em><em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nprod</em><em>, </em><em>ntime</em><em>]</em>) – If timestream is an np.ndarray containing the visiblities, then you
must also pass the corresponding freq, prod, input, and time axis as kwargs.
Otherwise these quantities are obtained from the attributes of CorrData.
If the visibilities have been stacked, then you must additionally pass the
stack and reverse_stack axis as kwargs, and (optionally) the input flags.</p></li>
<li><p><strong>copy</strong> (<em>bool</em>) – Create a copy of the input visibilities.  Apply the timing correction to
the copy and return it, leaving the original untouched.  Default is False.</p></li>
<li><p><strong>freq</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>]</em>) – Frequency in MHz.
Must be passed as keyword argument if timestream is an np.ndarray.</p></li>
<li><p><strong>prod</strong> (<em>np.ndarray</em><em>[</em><em>nprod</em><em>,  </em><em>]</em>) – Product map.
Must be passed as keyword argument if timestream is an np.ndarray.</p></li>
<li><p><strong>time</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>, </em><em>]</em>) – Unix time.
Must be passed as keyword argument if timestream is an np.ndarray.</p></li>
<li><p><strong>input</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – Input axis.
Must be passed as keyword argument if timestream is an np.ndarray.</p></li>
<li><p><strong>stack</strong> (<em>np.ndarray</em><em>[</em><em>nstack</em><em>, </em><em>]</em>) – Stack axis.
Must be passed as keyword argument if timestream is an np.ndarray
and the visibilities have been stacked.</p></li>
<li><p><strong>reverse_stack</strong> (<em>np.ndarray</em><em>[</em><em>nprod</em><em>, </em><em>] </em><em>of dtype=</em><em>(</em><em>'stack'</em><em>, </em><em>'conjugate'</em><em>)</em>) – The index of the stack axis that each product went into.
Typically found in <cite>reverse_map[‘stack’]</cite> attribute.
Must be passed as keyword argument if timestream is an np.ndarray
and the visibilities have been stacked.</p></li>
<li><p><strong>input_flags</strong> (<em>np.ndarray</em><em> [</em><em>ninput</em><em>, </em><em>ntime</em><em>]</em>) – Array indicating which inputs were good at each time.  Non-zero value
indicates that an input was good.  Optional.  Only used for stacked visibilities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><em>If copy == True</em> –</p>
<dl class="simple">
<dt>vis<span class="classifier">np.ndarray[nfreq, nprod(nstack), ntime]</span></dt><dd><p>New set of visibilities with timing correction applied.</p>
</dd>
</dl>
</li>
<li><p><em>else</em> –</p>
<dl class="simple">
<dt>None</dt><dd><p>Correction is applied to the input visibility data.  Also,
if timestream is an andata.CorrData instance and the gain dataset exists,
then it will be updated with the complex gains that have been applied.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.coeff_alpha">
<em class="property">property </em><code class="sig-name descname">coeff_alpha</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.coeff_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the coeff_alpha array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.coeff_tau">
<em class="property">property </em><code class="sig-name descname">coeff_tau</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.coeff_tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the coeff_tau array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.delete_coeff">
<code class="sig-name descname">delete_coeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.delete_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.delete_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop using coefficients to construct timing correction.</p>
<p>Calling this method will delete the <cite>coeff_tau</cite>, <cite>coeff_alpha</cite>,
and <cite>reference_noise_source</cite> datasets if they exist.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.freq">
<em class="property">property </em><code class="sig-name descname">freq</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the frequency bin centres.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a TimingCorrection object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>] </em><em>of dtype=</em><em>(</em><em>'centre'</em><em>, </em><em>'width'</em><em>)</em>) – Frequencies in MHz that were used to construct the timing correction.</p></li>
<li><p><strong>noise_source</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>,</em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – Correlator inputs that were used to construct the timing correction.</p></li>
<li><p><strong>input</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – Correlator inputs to which the timing correction will be applied.</p></li>
<li><p><strong>time</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>, </em><em>]</em>) – Unix time.</p></li>
<li><p><strong>param</strong> (<em>np.ndarray</em><em>[</em><em>nparam</em><em>, </em><em>]</em>) – Parameters of the model fit to the static phase versus frequency.</p></li>
<li><p><strong>tau</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>, </em><em>ntime</em><em>]</em>) – The actual timing correction, which is the relative delay of each of the
noise source inputs with respect to a reference input versus time.</p></li>
<li><p><strong>weight_tau</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>, </em><em>ntime</em><em>]</em>) – Estimate of the uncertainty (inverse variance) on the timing correction.</p></li>
<li><p><strong>static_phi</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – The phase that was subtracted from each frequency and input prior to
fitting for the timing correction.  This is necessary to remove the
approximately static ripple pattern caused by reflections.</p></li>
<li><p><strong>weight_static_phi</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – Inverse variance on static_phi.</p></li>
<li><p><strong>static_phi_fit</strong> (<em>np.ndarray</em><em>[</em><em>nparam</em><em>, </em><em>nsource</em><em>]</em>) – Best-fit parameters of a fit to the static phase versus frequency
for each of the noise source inputs.</p></li>
<li><p><strong>alpha</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>, </em><em>ntime</em><em>]</em>) – The coefficient of the spectral model of the amplitude variations of
each of the noise source inputs versus time.</p></li>
<li><p><strong>weight_alpha</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>, </em><em>ntime</em><em>]</em>) – Estimate of the uncertainty (inverse variance) on the amplitude coefficients.</p></li>
<li><p><strong>static_amp</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – The amplitude that was subtracted from each frequency and input prior to
fitting for the amplitude variations.  This is necessary to remove the
approximately static ripple pattern caused by reflections.</p></li>
<li><p><strong>weight_static_amp</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – Inverse variance on static_amp.</p></li>
<li><p><strong>num_freq</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>, </em><em>ntime</em><em>]</em>) – The number of frequencies used to determine the delay and alpha quantities.
If num_freq is 0, then that time is ignored when deriving the timing correction.</p></li>
<li><p><strong>coeff_tau</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>nsource</em><em>]</em>) – If coeff is provided, then the timing correction applied to a particular
input will be the linear combination of the tau correction from the
noise source inputs, with the coefficients set by this array.</p></li>
<li><p><strong>coeff_alpha</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>nsource</em><em>]</em>) – If coeff is provided, then the timing correction applied to a particular
input will be adjusted by the linear combination of the alpha correction
from the noise source inputs, with the coefficients set by this array.</p></li>
<li><p><strong>reference_noise_source</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>]</em>) – The noise source input that was used as reference when fitting coeff_tau.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.get_alpha">
<code class="sig-name descname">get_alpha</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timestamp</span></em>, <em class="sig-param"><span class="n">interp</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">extrap_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.get_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.get_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the amplitude variation for each noise source at the requested times.</p>
<p>Uses the TimingInterpolator to interpolate to the requested times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>,</em><em>]</em>) – Unix timestamp.</p></li>
<li><p><strong>interp</strong> (<em>string</em>) – Method to interpolate over time.  Options include ‘linear’, ‘nearest’,
‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’, and ‘next’.</p></li>
<li><p><strong>extrap_limit</strong> (<em>float</em>) – Do not extrapolate the underlying data beyond its boundaries by this
amount in seconds.  Default is 2 integrations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>np.ndarray[nsource, ntime]</em>) – Amplitude coefficient as a function of time for each of the noise sources.</p></li>
<li><p><strong>weight</strong> (<em>np.ndarray[nsource, ntime]</em>) – The uncertainty on the amplitude coefficient, expressed as an inverse variance.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.get_gain">
<code class="sig-name descname">get_gain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">timestamp</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.get_gain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.get_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex gain for the requested frequencies, inputs, and times.</p>
<p>Multiplying the visibilities by the outer product of these gains will remove
the fluctuations in phase due to timing jitter.  This method uses the
get_tau method.  It acccepts and passes along keyword arguments for that method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>]</em>) – Frequency in MHz.</p></li>
<li><p><strong>inputs</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>]</em>) – Must contain ‘correlator_input’ field.</p></li>
<li><p><strong>timestamp</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>, </em><em>]</em>) – Unix timestamps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gain</strong> (<em>np.ndarray[nfreq, ninput, ntime]</em>) – Complex gain.  Multiplying the visibilities by the
outer product of this vector at a given time and
frequency will correct for the timing jitter.</p></li>
<li><p><strong>weight</strong> (<em>np.ndarray[nfreq, ninput, ntime]</em>) – Uncerainty on the gain expressed as an inverse variance.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.get_stacked_alpha">
<code class="sig-name descname">get_stacked_alpha</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timestamp</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">prod</span></em>, <em class="sig-param"><span class="n">reverse_stack</span></em>, <em class="sig-param"><span class="n">input_flags</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.get_stacked_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.get_stacked_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the equivalent of <cite>get_stacked_tau</cite> for the noise source amplitude variations.</p>
<p>Averages the alphas from the noise source inputs that map to the set of redundant
baseline included in each stacked visibility.  If input_flags is provided, then the
bad inputs that were excluded from the stack are also excluded from the alpha
template averaging.  This method can be used to generate a stacked alpha template
that can be used to correct a stacked tau template for variations in the noise source
distribution system.  However, it is recommended that the tau template be corrected
before stacking. This is accomplished by setting the <cite>amp_to_delay</cite> property
prior to calling <cite>get_stacked_tau</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>,</em><em>]</em>) – Unix timestamp.</p></li>
<li><p><strong>inputs</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>,</em><em>]</em>) – Must contain ‘correlator_input’ field.</p></li>
<li><p><strong>prod</strong> (<em>np.ndarray</em><em>[</em><em>nprod</em><em>,</em><em>]</em>) – The products that were included in the stack.
Typically found in the <cite>index_map[‘prod’]</cite> attribute of the
<cite>andata.CorrData</cite> object.</p></li>
<li><p><strong>reverse_stack</strong> (<em>np.ndarray</em><em>[</em><em>nprod</em><em>,</em><em>] </em><em>of dtype=</em><em>(</em><em>'stack'</em><em>, </em><em>'conjugate'</em><em>)</em>) – The index of the stack axis that each product went into.
Typically found in <cite>reverse_map[‘stack’]</cite> attribute
of the <cite>andata.CorrData</cite>.</p></li>
<li><p><strong>input_flags</strong> (<em>np.ndarray</em><em> [</em><em>ninput</em><em>, </em><em>ntime</em><em>]</em>) – Array indicating which inputs were good at each time.
Non-zero value indicates that an input was good.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>alpha</strong> – Noise source amplitude variation as a function of time for each stacked visibility.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray[nstack, ntime]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.get_stacked_tau">
<code class="sig-name descname">get_stacked_tau</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timestamp</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">prod</span></em>, <em class="sig-param"><span class="n">reverse_stack</span></em>, <em class="sig-param"><span class="n">input_flags</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.get_stacked_tau"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.get_stacked_tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the appropriate delay for each stacked visibility at the requested time.</p>
<p>Averages the delays from the noise source inputs that map to the set of redundant
baseline included in each stacked visibility.  This yields the appropriate
common-mode delay correction.  If input_flags is provided, then the bad inputs
that were excluded from the stack are also excluded from the delay template averaging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>,</em><em>]</em>) – Unix timestamp.</p></li>
<li><p><strong>inputs</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>,</em><em>]</em>) – Must contain ‘correlator_input’ field.</p></li>
<li><p><strong>prod</strong> (<em>np.ndarray</em><em>[</em><em>nprod</em><em>,</em><em>]</em>) – The products that were included in the stack.
Typically found in the <cite>index_map[‘prod’]</cite> attribute of the
<cite>andata.CorrData</cite> object.</p></li>
<li><p><strong>reverse_stack</strong> (<em>np.ndarray</em><em>[</em><em>nprod</em><em>,</em><em>] </em><em>of dtype=</em><em>(</em><em>'stack'</em><em>, </em><em>'conjugate'</em><em>)</em>) – The index of the stack axis that each product went into.
Typically found in <cite>reverse_map[‘stack’]</cite> attribute
of the <cite>andata.CorrData</cite>.</p></li>
<li><p><strong>input_flags</strong> (<em>np.ndarray</em><em> [</em><em>ninput</em><em>, </em><em>ntime</em><em>]</em>) – Array indicating which inputs were good at each time.
Non-zero value indicates that an input was good.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tau</strong> – Delay as a function of time for each stacked visibility.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray[nstack, ntime]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.get_tau">
<code class="sig-name descname">get_tau</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timestamp</span></em>, <em class="sig-param"><span class="n">ignore_amp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">interp</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">extrap_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.get_tau"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.get_tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the delay for each noise source at the requested times.</p>
<p>Uses the TimingInterpolator to interpolate to the requested times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>,</em><em>]</em>) – Unix timestamp.</p></li>
<li><p><strong>ignore_amp</strong> (<em>bool</em>) – Do not apply a noise source based amplitude correction, even if one exists.</p></li>
<li><p><strong>interp</strong> (<em>string</em>) – Method to interpolate over time.  Options include ‘linear’, ‘nearest’,
‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’, and ‘next’.</p></li>
<li><p><strong>extrap_limit</strong> (<em>float</em>) – Do not extrapolate the underlying data beyond its boundaries by this
amount in seconds.  Default is 2 integrations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>tau</strong> (<em>np.ndarray[nsource, ntime]</em>) – Delay as a function of time for each of the noise sources.</p></li>
<li><p><strong>weight</strong> (<em>np.ndarray[nsource, ntime]</em>) – The uncertainty on the delay, expressed as an inverse variance.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.get_timing_correction">
<code class="sig-name descname">get_timing_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">timestamp</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.get_timing_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.get_timing_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the phase correction from each noise source at the requested frequency and time.</p>
<p>Assumes the phase correction scales with frequency nu as phi = 2 pi nu tau and uses the
get_tau method to interpolate over time. It acccepts and passes along keyword arguments
for that method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>]</em>) – Frequency in MHz.</p></li>
<li><p><strong>timestamp</strong> (<em>np.ndarray</em><em>[</em><em>ntime</em><em>, </em><em>]</em>) – Unix timestamp.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gain</strong> (<em>np.ndarray[nfreq, nsource, ntime]</em>) – Complex gain containing a pure phase correction for each of the noise sources.</p></li>
<li><p><strong>weight</strong> (<em>np.ndarray[nfreq, nsource, ntime]</em>) – Uncerainty on the gain for each of the noise sources, expressed as an inverse variance.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.has_amplitude">
<em class="property">property </em><code class="sig-name descname">has_amplitude</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.has_amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if this timing correction contains amplitude data.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.has_coeff_alpha">
<em class="property">property </em><code class="sig-name descname">has_coeff_alpha</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.has_coeff_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates if there are valid coeff that map noise source alpha to inputs.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.has_coeff_tau">
<em class="property">property </em><code class="sig-name descname">has_coeff_tau</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.has_coeff_tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates if there are valid coeff that map noise source tau to inputs.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.has_num_freq">
<em class="property">property </em><code class="sig-name descname">has_num_freq</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.has_num_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Inidicates if there is a num_freq flag that identifies missing data.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.input">
<em class="property">property </em><code class="sig-name descname">input</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.input" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the correlator inputs.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.noise_source">
<em class="property">property </em><code class="sig-name descname">noise_source</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.noise_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the noise source inputs.</p>
<p>Note that in older versions of the timing correction, the
noise_source axis does not exist.  Instead, the equivalent
quantity is labeled as input.  Since the addition of the
coeff dataset it has become necessary to distinguish between the
noise source inputs from which the timing correction is derived
and the correlator inputs to which the timing correction is applied.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.nsource">
<em class="property">property </em><code class="sig-name descname">nsource</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.nsource" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the number of noise source inputs.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.num_freq">
<em class="property">property </em><code class="sig-name descname">num_freq</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.num_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the num_freq array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.reference_noise_source">
<em class="property">property </em><code class="sig-name descname">reference_noise_source</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.reference_noise_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the reference noise source.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.search_input">
<code class="sig-name descname">search_input</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inputs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.search_input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.search_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Find inputs in the input axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inputs</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>,</em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – Indices of the input axis that yield the requested inputs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray[ninput,] of np.int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.set_coeff">
<code class="sig-name descname">set_coeff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coeff_tau</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">noise_source</span></em>, <em class="sig-param"><span class="n">coeff_alpha</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reference_noise_source</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.set_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.set_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Use coefficients to construct timing correction.</p>
<p>Setting the coefficients changes how the timing corretion for a particular
correlator input is derived.  Without coefficients, each input is matched
to the timing correction from a single noise source input through the
map_input_to_noise_source method.  With coefficients, each input is a
linear combination of the timing correction from all noise source inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff_tau</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>nsource</em><em>]</em>) – The timing correction applied to a particular input will be the
linear combination of the tau correction from the noise source inputs,
with the coefficients set by this array.</p></li>
<li><p><strong>inputs</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – Correlator inputs to which the timing correction will be applied.</p></li>
<li><p><strong>noise_source</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>,</em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – Correlator inputs that were used to construct the timing correction.</p></li>
<li><p><strong>coeff_alpha</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>nsource</em><em>]</em>) – The timing correction applied to a particular input will be adjusted by
the linear combination of the alpha correction from the noise source inputs,
with the coefficients set by this array.</p></li>
<li><p><strong>reference_noise_source</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>,</em><em>]</em>) – For each input, the index into noise_source that was used as
reference in the fit for coeff_tau.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.set_global_reference_time">
<code class="sig-name descname">set_global_reference_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tref</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">interpolate</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.set_global_reference_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.set_global_reference_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the delay and alpha template to the value at a single time.</p>
<p>Useful for referencing the template to the value at the time that
you plan to calibrate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tref</strong> (<em>unix time</em>) – Reference the templates to the values at this time.</p></li>
<li><p><strong>window</strong> (<em>float</em>) – Reference the templates to the median value over a window (in seconds)
around tref.  If nonzero, this will override the interpolate keyword.</p></li>
<li><p><strong>interpolate</strong> (<em>bool</em>) – Interpolate the delay template to time tref.  Otherwise take the measured time
nearest to tref.  The get_tau method is use to perform the interpolation, and
kwargs for that method will be passed along.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.set_reference_time">
<code class="sig-name descname">set_reference_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tref</span></em>, <em class="sig-param"><span class="n">tstart</span></em>, <em class="sig-param"><span class="n">tend</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tinit</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tau_init</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">alpha_init</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">interpolate</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.set_reference_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.set_reference_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the delay and alpha template to specific times.</p>
<p>Required if applying the timing correction to data that has
already been calibrated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tref</strong> (<em>np.ndarray</em><em>[</em><em>nref</em><em>]</em>) – Reference the delays to the values at this unix time.</p></li>
<li><p><strong>tstart</strong> (<em>np.ndarray</em><em>[</em><em>nref</em><em>]</em>) – Begin transition to the reference delay at this unix time.</p></li>
<li><p><strong>tend</strong> (<em>np.ndarray</em><em>[</em><em>nref</em><em>]</em>) – Complete transition to the reference delay at this unix time.</p></li>
<li><p><strong>tinit</strong> (<em>float</em>) – Use the delay at this time for the period before the first tstart.
Takes prescendent over tau_init.</p></li>
<li><p><strong>tau_init</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>]</em>) – Use this delay for times before the first tstart.  Must provide a value
for each noise source input.  If None, then will reference with respect
to the average delay over the full time series.</p></li>
<li><p><strong>alpha_init</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>]</em>) – Use this alpha for times before the first tstart.  Must provide a value
for each noise source input.  If None, then will reference with respect
to the average alpha over the full time series.</p></li>
<li><p><strong>interpolate</strong> (<em>bool</em>) – Interpolate the delay template to times tref. Otherwise take the measured
times nearest to tref. The get_tau method is use to perform the
interpolation, and kwargs for that method will be passed along.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.static_amp">
<em class="property">property </em><code class="sig-name descname">static_amp</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.static_amp" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the static_amp array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.static_phi">
<em class="property">property </em><code class="sig-name descname">static_phi</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.static_phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the static_phi array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.static_phi_fit">
<em class="property">property </em><code class="sig-name descname">static_phi_fit</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.static_phi_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the static_phi_fit array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingCorrection.summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingCorrection.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a summary of the timing correction.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>summary</strong> – Contains useful information about the timing correction.
Specifically contains for each noise source input the
time averaged  phase offset and delay.  Also contains
estimates of the variance in the timing for both the
shortest and longest timescale probed by the underlying
dataset.  Meant to be joined with new lines and printed.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of strings</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.tau">
<em class="property">property </em><code class="sig-name descname">tau</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the tau array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.weight_alpha">
<em class="property">property </em><code class="sig-name descname">weight_alpha</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.weight_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the weight_alpha array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.weight_static_amp">
<em class="property">property </em><code class="sig-name descname">weight_static_amp</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.weight_static_amp" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the weight_static_amp array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.weight_static_phi">
<em class="property">property </em><code class="sig-name descname">weight_static_phi</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.weight_static_phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the weight_static_phi array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.weight_tau">
<em class="property">property </em><code class="sig-name descname">weight_tau</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.weight_tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide convenience access to the weight_tau array.</p>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingCorrection.zero_delay_noise_source">
<em class="property">property </em><code class="sig-name descname">zero_delay_noise_source</code><a class="headerlink" href="#ch_util.timing.TimingCorrection.zero_delay_noise_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the noise source with zero delay.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ch_util.timing.TimingData">
<em class="property">class </em><code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">TimingData</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h5_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ch_util.andata.html#ch_util.andata.CorrData" title="ch_util.andata.CorrData"><code class="xref py py-class docutils literal notranslate"><span class="pre">ch_util.andata.CorrData</span></code></a>, <a class="reference internal" href="#ch_util.timing.TimingCorrection" title="ch_util.timing.TimingCorrection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ch_util.timing.TimingCorrection</span></code></a></p>
<p>Subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">andata.CorrData</span></code> for timing data.</p>
<p>Automatically computes the timing correction when data is loaded and
inherits the methods of <a class="reference internal" href="#ch_util.timing.TimingCorrection" title="ch_util.timing.TimingCorrection"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimingCorrection</span></code></a> that enable the application
of that correction to other datasets.</p>
<p>Used to pick which subclass to instantiate based on attributes in
data.</p>
<dl class="py method">
<dt id="ch_util.timing.TimingData.from_acq_h5">
<em class="property">classmethod </em><code class="sig-name descname">from_acq_h5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">acq_files</span></em>, <em class="sig-param"><span class="n">only_correction</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingData.from_acq_h5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingData.from_acq_h5" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a list of acquisition files and computes the timing correction.</p>
<p>Accepts and passes on all keyword arguments for andata.CorrData.from_acq_h5
and the construct_delay_template function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>acq_files</strong> (<em>str</em><em> or </em><em>list of str</em>) – Path to file(s) containing the timing data.</p></li>
<li><p><strong>only_correction</strong> (<em>bool</em>) – Only return the timing correction.  Do not return the underlying
data from which that correction was derived.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>data</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ch_util.timing.TimingData" title="ch_util.timing.TimingData">TimingData</a> or <a class="reference internal" href="#ch_util.timing.TimingCorrection" title="ch_util.timing.TimingCorrection">TimingCorrection</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ch_util.timing.TimingData.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingData.summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingData.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a summary of the timing data and correction.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>summary</strong> – Contains useful information about the timing correction
and data.  Includes the reduction in the standard deviation
of the phase after applying the timing correction.  This is
presented as quantiles over frequency for each of the
noise source products.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of strings</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ch_util.timing.TimingInterpolator">
<em class="property">class </em><code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">TimingInterpolator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">flag</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">extrap_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#TimingInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.TimingInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interpolation that is aware of flagged data and weights.</p>
<p>Flagged data is ignored during the interpolation. The weights from
the data are propagated to obtain weights for the interpolated points.</p>
<p>Instantiate a callable TimingInterpolator object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em><em>[</em><em>nsample</em><em>,</em><em>]</em>) – The points where the data was sampled.
Must be monotonically increasing.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em><em>[</em><em>..</em><em>, </em><em>nsample</em><em>]</em>) – The data to interpolate.</p></li>
<li><p><strong>weight</strong> (<em>np.ndarray</em><em>[</em><em>..</em><em>, </em><em>nsample</em><em>]</em>) – The uncertainty on the data, expressed as an
inverse variance.</p></li>
<li><p><strong>flag</strong> (<em>np.ndarray</em><em>[</em><em>..</em><em>, </em><em>nsample</em><em>]</em>) – Boolean indicating if the data is to be
included in the interpolation.</p></li>
<li><p><strong>kind</strong> (<em>str</em>) – String that specifies the kind of interpolation.
The value <cite>nearest</cite>, <cite>previous</cite>, <cite>next</cite>, and <cite>linear</cite> will use
custom methods that propagate uncertainty to obtain the interpolated
weights. The value <cite>zero</cite>, <cite>slinear</cite>, <cite>quadratic</cite>, and <cite>cubic</cite>
will use spline interpolation from scipy.interpolation.interp1d
and use the weight from the nearest point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>interpolator</strong> – Callable that will interpolate the data that was provided
to a new set of x values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ch_util.timing.TimingInterpolator" title="ch_util.timing.TimingInterpolator">TimingInterpolator</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ch_util.timing.construct_delay_template">
<code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">construct_delay_template</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">min_frac_kept</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">min_freq</span><span class="o">=</span><span class="default_value">420.0</span></em>, <em class="sig-param"><span class="n">max_freq</span><span class="o">=</span><span class="default_value">780.0</span></em>, <em class="sig-param"><span class="n">mask_rfi</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_iter_weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">check_amp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">nsigma_amp</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">check_phi</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">nsigma_phi</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nparam</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">static_phi</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight_static_phi</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">static_phi_fit</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">static_amp</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight_static_amp</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#construct_delay_template"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.construct_delay_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a relative time delay template.</p>
<p>Fits the phase of the cross-correlation between noise source inputs
to a model that increases linearly with frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="ch_util.andata.html#ch_util.andata.CorrData" title="ch_util.andata.CorrData"><em>andata.CorrData</em></a>) – <dl class="simple">
<dt>Correlation data.  Must contain the following attributes:</dt><dd><dl class="simple">
<dt>freq: np.ndarray[nfreq, ]</dt><dd><p>Frequency in MHz.</p>
</dd>
<dt>vis: np.ndarray[nfreq, nprod, ntime]</dt><dd><p>Upper-triangle, product packed visibility matrix
containing ONLY the noise source inputs.</p>
</dd>
<dt>weight: np.ndarray[nfreq, nprod, ntime]</dt><dd><p>Flag indicating the data points to fit.</p>
</dd>
<dt>flags/frac_lost: np.ndarray[nfreq, ntime]</dt><dd><p>Flag indicating the fraction of data lost.
If provided, then data will be weighted by the
fraction of data that remains when solving
for the delay template.</p>
</dd>
</dl>
</dd>
</dl>
</p></li>
<li><p><strong>min_frac_kept</strong> (<em>float</em>) – Do not include frequencies and times where the fraction
of data that remains is less than this threshold.
Default is 0.0.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – A (frequency, input) must pass the checks specified above
more than this fraction of the time,  otherwise it will be
flaged as bad for all times.  Default is 0.50.</p></li>
<li><p><strong>min_freq</strong> (<em>float</em>) – Minimum frequency in MHz to include in the fit.
Default is 420.</p></li>
<li><p><strong>max_freq</strong> (<em>float</em>) – Maximum frequency in MHz to include in the fit.
Default is 780.</p></li>
<li><p><strong>mask_rfi</strong> (<em>bool</em>) – Mask frequencies that occur within known RFI bands.  Note that the
noise source data does not contain RFI, however the real-time pipeline
does not distinguish between noise source inputs and sky inputs, and as
a result will discard large amounts of data in these bands.</p></li>
<li><p><strong>max_iter_weight</strong> (<em>int</em>) – The weight for each frequency is estimated from the variance of the
residuals of the template fit from the previous iteration.  Outliers
are also flagged at each iteration with an increasingly aggresive threshold.
This is the total number of times to iterate.  Setting to 1 corresponds
to linear least squares.  Default is 1, unless check_amp or check_phi is True,
in which case this defaults to the maximum number of thresholds provided.</p></li>
<li><p><strong>check_amp</strong> (<em>bool</em>) – Do not fit frequencies and times where the residual amplitude is an outlier.
Default is False.</p></li>
<li><p><strong>nsigma_amp</strong> (<em>list of float</em>) – If check_amp is True, then residuals greater than this number of sigma
will be considered an outlier.  Provide a list containing the value to be used
at each iteration.  If the length of the list is less than max_iter_weight,
then the last value in the list will be repeated for the remaining iterations.
Default is [1000, 500, 200, 100, 50, 20, 10, 5].</p></li>
<li><p><strong>check_phi</strong> (<em>bool</em>) – Do not fit frequencies and times where the residual phase is an outlier.
Default is True.</p></li>
<li><p><strong>nsigma_phi</strong> (<em>list of float</em>) – If check_phi is True, then residuals greater than this number of sigma
will be considered an outlier.  Provide a list containing the value to be used
at each iteration.  If the length of the list is less than max_iter_weight,
then the last value in the list will be repeated for the remaining iterations.
Default is [1000, 500, 200, 100, 50, 20, 10, 5].</p></li>
<li><p><strong>nparam</strong> (<em>int</em>) – Number of parameters for polynomial fit to the
time averaged phase versus frequency.  Default is 2.</p></li>
<li><p><strong>static_phi</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – Subtract this quantity from the noise source phase prior to fitting
for the timing correction.  If None, then this will be estimated from the median
of the noise source phase over time.</p></li>
<li><p><strong>weight_static_phi</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – Inverse variance of the time averaged phased.  Set to zero for frequencies and inputs
that are missing or should be ignored.  If None, then this will be estimated from the
residuals of the fit.</p></li>
<li><p><strong>static_phi_fit</strong> (<em>np.ndarray</em><em>[</em><em>nparam</em><em>, </em><em>nsource</em><em>]</em>) – Polynomial fit to static_phi versus frequency.</p></li>
<li><p><strong>static_amp</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – Subtract this quantity from the noise source amplitude prior to fitting
for the amplitude variations.  If None, then this will be estimated from the median
of the noise source amplitude over time.</p></li>
<li><p><strong>weight_static_amp</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>]</em>) – Inverse variance of the time averaged amplitude.  Set to zero for frequencies and inputs
that are missing or should be ignored.  If None, then this will be estimated from the
residuals of the fit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>phi</strong> (<em>np.ndarray[nfreq, nsource, ntime]</em>) – Phase of the signal from the noise source.</p></li>
<li><p><strong>weight_phi</strong> (<em>np.ndarray[nfreq, nsource, ntime]</em>) – Inverse variance of the phase of the signal from the noise source.</p></li>
<li><p><strong>tau</strong> (<em>np.ndarray[nsource, ntime]</em>) – Delay template for each noise source input.</p></li>
<li><p><strong>weight_tau</strong> (<em>np.ndarray[nfreq, nsource]</em>) – Estimate of the uncertainty on the delay template (inverse variance).</p></li>
<li><p><strong>static_phi</strong> (<em>np.ndarray[nfreq, nsource]</em>) – Time averaged phase versus frequency.</p></li>
<li><p><strong>weight_static_phi</strong> (<em>np.ndarray[nfreq, nsource]</em>) – Inverse variance of the time averaged phase.</p></li>
<li><p><strong>static_phi_fit</strong> (<em>np.ndarray[nparam, nsource]</em>) – Best-fit parameters of the polynomial fit to the
time averaged phase versus frequency.</p></li>
<li><p><strong>amp</strong> (<em>np.ndarray[nfreq, nsource, ntime]</em>) – Amplitude of the signal from the noise source.</p></li>
<li><p><strong>weight_amp</strong> (<em>np.ndarray[nfreq, nsource, ntime]</em>) – Inverse variance of the amplitude of the signal from the noise source.</p></li>
<li><p><strong>alpha</strong> (<em>np.ndarray[nsource, ntime]</em>) – Amplitude coefficient for each noise source input.</p></li>
<li><p><strong>weight_alpha</strong> (<em>np.ndarray[nfreq, nsource]</em>) – Estimate of the uncertainty on the amplitude coefficient (inverse variance).</p></li>
<li><p><strong>static_amp</strong> (<em>np.ndarray[nfreq, nsource]</em>) – Time averaged amplitude versus frequency.</p></li>
<li><p><strong>weight_static_amp</strong> (<em>np.ndarray[nfreq, nsource]</em>) – Inverse variance of the time averaged amplitude.</p></li>
<li><p><strong>num_freq</strong> (<em>np.ndarray[nsource, ntime]</em>) – Number of frequencies used to construct the delay and amplitude templates.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ch_util.timing.eigen_decomposition">
<code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">eigen_decomposition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vis</span></em>, <em class="sig-param"><span class="n">flag</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#eigen_decomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.eigen_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalue decomposition of the visibility matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nprod</em><em>, </em><em>ntime</em><em>]</em>) – Upper-triangle, product packed visibility matrix.</p></li>
<li><p><strong>flag</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>nsource</em><em>, </em><em>ntime</em><em>] </em><em>(</em><em>optional</em><em>)</em>) – Array of 1 or 0 indicating the inputs that should be included
in the eigenvalue decomposition for each frequency and time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>resp</strong> – Eigenvector corresponding to the largest eigenvalue for
each frequency and time.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray[nfreq, nsource, ntime]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ch_util.timing.fit_poly_to_phase">
<code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">fit_poly_to_phase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">resp</span></em>, <em class="sig-param"><span class="n">resp_error</span></em>, <em class="sig-param"><span class="n">nparam</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#fit_poly_to_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.fit_poly_to_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit complex data versus frequency to a model consisting of a polynomial in phase.</p>
<p>Nonlinear least squares algorithm is applied to the complex data to avoid problems
caused by phase wrapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>]</em>) – Frequency in MHz.</p></li>
<li><p><strong>resp</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>]</em>) – Complex data with magnitude equal to 1.0.</p></li>
<li><p><strong>resp_error</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>]</em>) – Uncertainty on the complex data.</p></li>
<li><p><strong>nparam</strong> (<em>int</em>) – Number of parameters in the polynomial.
Default is 2 (i.e, linear).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>popt</strong> (<em>np.ndarray[nparam, ]</em>) – Best-fit parameters.</p></li>
<li><p><strong>pcov</strong> (<em>np.ndarray[nparam, nparam]</em>) – Covariance of the best-fit parameters.
Assumes that it obtained a good fit
and returns the errors
necessary to achieve that.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ch_util.timing.load_timing_correction">
<code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">load_timing_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">files</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">43200.0</span></em>, <em class="sig-param"><span class="n">instrument</span><span class="o">=</span><span class="default_value">'chime'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#load_timing_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.load_timing_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and load the appropriate timing correction for a list of corr acquisition files.</p>
<p>For example, if the instrument keyword is set to ‘chime’,
then this function will accept all types of chime corr acquisition files,
such as ‘chimetiming’, ‘chimepb’, ‘chimeN2’, ‘chimecal’, and then find
the relevant set of ‘chimetiming’ files to load.</p>
<p>Accepts and passes on all keyword arguments for the functions
andata.CorrData.from_acq_h5 and construct_delay_template.</p>
<p>Should consider modifying this method to use Finder at some point in future.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>files</strong> (<em>string</em><em> or </em><em>list of strings</em>) – Absolute path to corr acquisition file(s).</p></li>
<li><p><strong>start</strong> (<em>integer</em><em>, </em><em>optional</em>) – What frame to start at in the full set of files.</p></li>
<li><p><strong>stop</strong> (<em>integer</em><em>, </em><em>optional</em>) – What frame to stop at in the full set of files.</p></li>
<li><p><strong>window</strong> (<em>float</em>) – Use the timing data -window from start and +window from stop.
Default is 12 hours.</p></li>
<li><p><strong>instrument</strong> (<em>string</em>) – Name of the instrument.  Default is ‘chime’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>data</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ch_util.timing.TimingData" title="ch_util.timing.TimingData">TimingData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ch_util.timing.map_input_to_noise_source">
<code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">map_input_to_noise_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">noise_sources</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#map_input_to_noise_source"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.map_input_to_noise_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the appropriate noise source to use to correct the phase of each input.</p>
<p>Searches for a noise source connected to the same slot,
then crate, then hut, then correlator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>np.ndarray</em><em>[</em><em>ninput</em><em>, </em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – The input axis from a data acquisition file.</p></li>
<li><p><strong>noise_sources</strong> (<em>np.ndarray</em><em>[</em><em>nsource</em><em>, </em><em>] </em><em>of dtype=</em><em>(</em><em>'chan_id'</em><em>, </em><em>'correlator_input'</em><em>)</em>) – The noise sources.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ch_util.timing.model_poly_phase">
<code class="sig-prename descclassname">ch_util.timing.</code><code class="sig-name descname">model_poly_phase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">param</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ch_util/timing.html#model_poly_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ch_util.timing.model_poly_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a polynomial model for the phase.</p>
<p>To be used with the parameters output from fit_poly_to_phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<em>np.ndarray</em><em>[</em><em>nfreq</em><em>, </em><em>]</em>) – Frequency in MHz.</p></li>
<li><p><strong>*param</strong> (<em>float</em>) – Coefficients of the polynomial.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>phi</strong> – Phase in radians between -pi and +pi.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray[nfreq, ]</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="ch_util.tools.html" class="btn btn-neutral float-right" title="ch_util.tools" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="ch_util.rfi.html" class="btn btn-neutral float-left" title="ch_util.rfi" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2013, CHIME Collaboration.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>